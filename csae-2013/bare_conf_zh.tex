
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}
\usepackage{zhspacing}
\zhspacing
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.





%% \usepackage[pdftex]{graphicx}
% *** GRAPHICS RELATED PACKAGES ***
%
\usepackage{graphicx}
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%% \usepackage[caption=false]{caption}
%% \usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
%% \hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\bibliographystyle{IEEEtran}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
%% \title{Bare Demo of IEEEtran.cls for Conferences}
\title{An abstraction for data-flow drived\\ concurrent programming}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Xing Su}
\IEEEauthorblockA{School of Computer Science\\
National University of Defense Technology\\
Changsha, China.\\
pysuxing@gmail.com}
\and
\IEEEauthorblockN{Longfei Guo, Bin Ren, Jin Ye, Wenhua Dou}
\IEEEauthorblockA{School of Computer Science\\
National University of Defense Technology\\
Changsha, China.\\
\{lfguo, bren, jye, whdou\}@nudt.edu.cn}
%% \and
%% \IEEEauthorblockN{James Kirk\\ and Montgomery Scott}
%% \IEEEauthorblockA{Starfleet Academy\\
%% San Francisco, California 96678-2391\\
%% Telephone: (800) 555--1212\\
%% Fax: (888) 555--1212}
}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}
%\boldmath
%% Concurrent programming has always been difficult because it's not as intuitional as sequential
%% programming. Programmers have to deal with subtle details such as forking threads and
%% synchronizing, which is tiresome and error prone . In this paper we 
%% design a high-level abstraction for data-flow drived concurrent programming using the functional
%% programming language Haskell. The abstraction provides a very clean, elegant and powerful
%% programming interface to the programmers so as to ease the work of concurrent programming.
%% Our abstract interface enables programmer to write sequential like programs while benefiting from
%% parallel hardware. The programs are automatically scheduled on multiple threads and run concurrently.
%% The performance is competitive and exceptions are handled properly.
和传统的传统串行程序设计相比，并行程序设计具有不直观、难度大的特点。编程者必须处理许多并发
相关的细节，如创建线程、线程同步等等。处理这些并发细节既耗费精力，又容易向程序逻辑中引入
错误。本文针对数据流驱动的并行编程问题设计了一种高层抽象模型，使用Haskell语言实现了该模型。
该抽象模型为编程者提供了一个简洁优雅的编程接口以简化并行程序设计的难度。使用我们提供的接口，
编程者可以使用传统串行编程方法，同时充分利用并行硬件提供的性能，程序将自动被分布到运行在
并行硬件之上的多个线程中执行。初步测试表明本编程接口可以提供优秀的性能，同时还具备异常处理
能力。
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



%% \section{Introduction}
% no \IEEEPARstart
%% This demo file is intended to serve as a ``starter file''
%% for IEEE conference papers produced under \LaTeX\ using
%% IEEEtran.cls version 1.7 and later.
% You must have at least 2 lines in the paragraph with the drop letter
% (should never be an issue)
%% I wish you the best of success.

%% \hfill mds
 
%% \hfill January 11, 2007

%% \subsection{Subsection Heading Here}
%% Subsection text here.


%% \subsubsection{Subsubsection Heading Here}
%% Subsubsection text here.


% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation Results}
%\label{fig_sim}
%\end{figure}

% Note that IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command, the
% \label for the overall figure must come after \caption.
% \hfil must be used as a separator to get equal spacing.
% The subfigure.sty package works much the same way, except \subfigure is
% used instead of \subfloat.
%
%\begin{figure*}[!t]
%\centerline{\subfloat[Case I]\includegraphics[width=2.5in]{subfigcase1}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{subfigcase2}%
%\label{fig_second_case}}}
%\caption{Simulation results}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.


% An example of a floating table. Note that, for IEEE style tables, the 
% \caption command should come BEFORE the table. Table text will default to
% \footnotesize as IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that IEEE does not put floats in the very first column - or typically
% anywhere on the first page for that matter. Also, in-text middle ("here")
% positioning is not used. Most IEEE journals/conferences use top floats
% exclusively. Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the \fnbelowfloat
% command of the stfloats package.

\section{Introduction}\label{sec:introduction}
%% Processors are not getting faster, instead the manufactors are providing us more and
%% more processors on a single chip. So concurrent programming is becoming the mainstream
%% programming technique. But concurrent programming has always been hard work. The logic
%% of concurrent programs are not as intuitional as the traditional sequential ones.
%% And programmers have to deal with lots of subtles details like forking threads,
%% synchronizing, catching exceptions etc.
当前，单个处理器的运算速度已经不再快速提高，计算机性能的提升主要依靠多核等并行硬件的
数量增长。因此，并行编程已经成为主流的编程技术。但是，
并行程序设计的逻辑结构不够直观，编程者需要处理线程并发、线程同步、异常处理等并行细节，
总体编程难度远远高于传统的串行程序设计。

%% People have been working to estimate the difficulty of concurrent programming. Some use
%% the Data Parallel techniques, which is adopted to vector processors and DSPs, and
%% works well in data oriented applications. Some trys to enhance the compiler to parallelise
%% the workload automatically which, however, is hark work. Some other methods need
%% the programmer give hints to the compiler in the code to explicitly figure out the parallel
%% part of the programs, for instance, CUDA programming with Nvidia GPUs.
研究者一直在努力降低并行程序设计的难度。已有的技术包括数据并行技术，如向量处理器与
DSP中使用的SIMD体系结构，这种技术在数据密集型应用中发挥了很好的性能。使编译器自动
分析程序中的并行部分并自动地将并行部分分布到多个线程中是理想的办法，但是，实现完全
的自动并行化难度极大。完全自动并行化的折中方案是，允许编程者在代码中增加一些指示，
将程序中的并行部分分离出来，辅助编译器进行自动并行华，这种方法也取得了成功，著名
的例子包括MPI与Openacc等。

%% We argue that a high-level abstraction of concurrent programming, which enforces the compiler
%% or library to do the hard work, can help wipe the subtle details out from the insight
%% of programmers. We designed an abstract interface for concurrent programmers
%% using the functional programming language Haskell,
%% and it simplify the work of concurrent programming a lot, especially for the data-flow
%% drived problems.
我们认为一种将并行化工作实现在编译器或程序库层的高层次的编程模型将大大简化并行程序设计。
我们针对数据流驱动的并行编程问题设计了一种高层编程模型，使用函数式编程语言Haskell实现
了该模型的编程接口。

%% In the following sections, we will show our design and its applications. In Section 2 we
%% describe the Data-flow drived problems and give a concrete example to work with in the
%% whole paper. In Section 3  afer a brief introduction to the Haskell language and
%% the concept of arrows which inspired our design, we will show our main design and
%% the implimentation. We enhance our design
%% with the ablility to deal with exceptions in Section 4. In Section 5 a simple test
%% application is shown. Conclusion comes last in Section 6, discussing the related work, advantages
%% and disadvantages of our approach and future work we will do.
本文将按照如下结构介绍我们的设计与实现。第2章我们将描述数据流驱动的并行编程问题，并给出
一个实例用于后文章节的分析。第3章首先介绍函数式编程语言Haskell，着重介绍Haskell语言中的arrow
接口，然后详细说明我们的抽象接口设计。在第4章中，我们为该接口增加异常处理的能力。第5章
使用一个测试程序说明本接口的性能。第6章总结，介绍相关工作，指出本接口的优势与下一步的工作。

\section{Data-flow Drived Problems}\label{sec:dataflow-drived-problems}
%% Many real-world problems can be abstracted to Data-flow problems. A Data-flow problem
%% can be expressed as a data-flow graph, in which each node represents a task, and each
%% directed edge represents some kind of dependency between tasks it connects, for instance,
%% data dependency or timing dependency.
许多现实问题可以抽象为数据流驱动的问题模型。数据流驱动问题模型可以用一副数据流图来表示，
数据流图是一个有项图，图中每一个结点表示一个任务，每一条有向边表示它所联结的两个任务间
的某种依赖关系，如数据依赖、时序依赖等。

%% To give a concrete example, consider the following problem. Suppose the family is going to hold
%% a party for Christmas Eve and everyone has got some work to do. Dad is responsible for
%% purchasing all raw materials and all other work need these materials. When the materials
%% are available, Mum will go to prepare dinner for the family. The three kids are also sent off
%% to do some work. Tommy will trim the Christmas tree, David will sweep the house, and little Lucy
%% will make some decorators for the house. When all the kids finish their work Dad will decorate the
%% house. The party will begin after the house is decorated and Mum has the
%% dinner prepared.
为了更加清晰地说明数据流驱动问题模型，这里给出一个具体例子，我们称之为圣诞派对问题。
假设全家人决定在圣诞夜举行一个新年派对，为了准备派对，每一个家庭成员都将负责若干准备
工作。爸爸负责购买派对所需的所有材料，包括晚饭的食材、点缀客厅的装饰品、清洁用具等。
妈妈负责准备晚饭。三个孩子也各自完成一项任务：托米修剪圣诞树，大卫打扫客厅，小露茜
制作装饰品。当三个孩子全部完成任务之后，爸爸将装饰房间。当房间装饰完毕，晚饭也就绪
之后，派对就可以开始了，全家人庆祝圣诞到来。

%% This problem can be expressed by a data-flow graph, as shown in figure \ref{fig:christmas-dataflow}.
%% From the figure we can see that some work should be done in parallel. Mum can cook dinner while
%% the kids are doing there work. If we are writing a program to simulate the whole preparation work
%% for Christmas Eve party, we should better fork a thread for each of the parallelisable work, thus
%% making the simulation running more faster than a sequential one.
前述的圣诞派对问题可以用图\ref{fig:christmas-dataflow}的数据流图表示。从图中可以看到，
有一些工作应该同时进行，三个孩子可以同时工作，妈妈也可已在孩子们忙碌的时候准备晚餐。
如果我们编程模拟整个派对的准备工作，每一项可以同时进行的工作都应该创建一个线程，这样
所有的准备工作就可以用较短的时间完成。
\begin{figure*}[!t]
  \centering
  \includegraphics[scale=0.4]{christmas-dataflow.png}
  \caption{The Chistmas Eve party data-flow}
  \label{fig:christmas-dataflow}
\end{figure*}
\begin{figure*}
  \begin{verbatim}
    id :: a b b                                    -- the identity arrow
    >>> :: a b c -> a c d -> a b d                 -- arrow composition
    arr :: (b -> c) -> a b c                       -- lift a general function to arrow
    (***) :: a b c -> a b' c' -> a (b, b') (c, c') -- combine two parallel arrows
    (&&&) :: a b c -> a b c' -> a b (c, c')        -- combine two arrows' result
  \end{verbatim}
  \caption{Combinators for arrow programming}
  \label{fig:arrows-interface}
\end{figure*}

\section{A High-level Abstraction}\label{sec:a-high-level-abstraction}
%% In this section, we will demonstrate our high-level abstraction for concurrent programming. First we
%% should give a brief introduction to the functional programming language Haskell. Then a solution of
%% the Christmas Eve problem using our abstraction interface will be shown, with a comparation to ordinary
%% programming technique. At last the implementation detail is described.
本章将说明我们的为数据流驱动问题设计的高层次抽象模型。首先简要介绍函数式编程
语言Haskell与arrow接口界面。之后，我们将使用该抽象接口编程实现圣诞派对问题，
并将该实现与传统的并行编程方案对比分析，展现本抽线接口的优点。最后，我们将
描述实现该高层接口的实现细节。

\subsection{Haskell Language and Arrows}\label{subsec:haskell-and-arrows}
\subsubsection{The Haskell Language}
%% The Haskell language is originally designed as a base language for researchers to explore new language
%% features. It belongs to the functional language family, in which there are some other widely known
%% languages such as Lisp and ML. 
Haskell语言最初为学术研究设计，目的是为程序语言特性的研究提供一个基础语言。它
属于函数式编程语言家族，这个家族中其他的著名语言包括ML与Lisp。

%% As a functional language, functions are first-class citizens in the language, that is, functions can be
%% passed as parameters, returned as a return value, or manipulated in any way. There can also be
%% anonymous functions. Haskell is a strong static typed language and everything has an associated type.
%% General functions in haskell has a type signature as below.
%% The type signature means that function \texttt{f} takes a parameter of
%% type \texttt{a} and return a value of type \texttt{b}.
作为一种典型的函数式编程语言，函数在Haskell语言中是“一等公民”，即函数的参数与
返回值都可以是函数，同时允许定义匿名函数。Haskell是一种静态强类型语言，语言中
允许出现的所有实体都具有特定的型别。下面的代码是一个函数的型别声明，它表示
函数\texttt{f}的型别为\texttt{a -> b}，也就是说，\texttt{f}具有一个型别为
\texttt{a}的参数，返回一个型别为\texttt{b}的结果。
\begin{verbatim}
            f :: a -> b
\end{verbatim}

\subsubsection{Arrows}
%% Haskell also provide a kind of generalised function, called Arrow \cite{Hughes2005}.
%% As the name suggests, it is
%% a directed arrow start from some type and end at some type. An arrow of the below type signature
%% means that it's take a computation of a value of type \texttt{a} and produce a computation of a value
%% of type \texttt{b}. Note an arrow take a computation of some type, not a value, though
%% the computation is related to the type. So is the returned computation. The computation is specified
%% by the definition of arrow type \texttt{SomeArrow}.
Haskell语言中有一种Arrow接口，是函数的泛化（generalised）形式\cite{Hughes2005}。
顾名思义，Arrow是一个从一种类型指向另一种类型的“箭头”。下列代码表示的arr具有
型别\texttt{SomeArrow a b}，表示arr是一种SomeArrow类型的arrow，它的输入是一种与
型别\texttt{a}相关的型别，输出是一种与型别\texttt{b}相关的型别。这里的相关，表示
从某种型别的某个值计算通过某种特定的计算得到另一个值，该相关关系如何定义则取决于
型别SomeArrow的定义。普通函数可以看作一种特别的Arrow。
\begin{verbatim}
      arr :: SomeArrow a b
\end{verbatim}

%% Arrows provide an elegant interface for programmers. The main combinator for arrows are listed in figure
%% \ref{fig:arrows-interface}. \texttt{id} is the identity arrow which output its input without any processing.
%% \texttt{>>>} connect tow arrow of type \texttt{A a b} and \texttt{A b c} and return a new arrow of type
%% \texttt{A a c}. \texttt{***} combines two arrows as one without affect each other. \texttt{\&\&\&} combines
%% two arrows' result.
Arrow为编程者提供了良好的编程接口。和Arrow相关的主要接口参见表\ref{fig:arrows-interface}。
\texttt{id}是直通arrow，直接将输入作为输出（不执行任何处理）。
\texttt{>>>}将两个arrow串联得到一个arrow，第一个arrow的输出作为第二个arrow的输入。
\texttt{***}将两个arrow并联得到一个arrow，两个arrow的输入输出彼此没有干扰。
\texttt{\&\&\&}将一个输入分流成为两路输入两个arrow，将两个arrow的结果合并成一个作为
总输出。

%% We will see that the arrow interface is used to model parallel tasks in the following subsections.
在后文中，我们将使用Arrow接口来描述并行任务。

\subsection{Abstraction of Data-flow Concurrent Programming}\label{subsec:abstraction-of-dataflow}
%% Recall the Christmas Eve problem in Section \ref{sec:dataflow-drived-problems}
%% and it's data-flow expression in figure \ref{fig:christmas-dataflow}.
%% We see that each task in the data-flow graph is an arrow! A task
%% may take some input from other task's output as well as produce some output which may be the
%% input of other tasks.
回忆第\ref{sec:dataflow-drived-problems}章中的圣诞派对问题，它的数据流图见图
\ref{fig:christmas-dataflow}，从图中可以看出，该问题中的每一个任务都可以用一个
箭头表示！完成一个任务需要若干前提条件，这些前提条件可能是通过完成其他任务才
可以具备的，而完成此任务也会为别的任务提供一些前提条件。

%% Translate the data-flow graph into code using our abstract interface requires little effort. See
%% the code shown in figure \ref{fig:code-christmas}. Some functions' type signatures are omitted for
%% the sake of space. Compared to ordinary concurrent code gluted with \texttt{fork}s and synchronous
%% code, it seems to be a sequential program! In fact, a sequential version can also be coded using
%% arrow interface and it looks exactly like our concurrent version in figure \ref{fig:code-christmas}.
使用我们的高层编程接口编程实现圣诞派对问题非常简单，具体代码参见图\ref{fig:code-christmas}。
由于空间限制，一些函数的型别说明在此处省略。如果使用通常的并行编程技术，代码中
难免要充斥着\texttt{fork}与\texttt{sync}操作，而使用我们的接口编写的程序，看起
来就像是普通的串行程序！实际上，使用arrow接口很容易实现圣诞派对问题的串行版本，
不同的是我们需要使用另一种arrow，而整个代码的框架结构是不许要改变的。

%% \texttt{CIO} is the arrow type we use to represent a parallel task. We use
%% \texttt{()} to indicate \texttt{NULL}, the arrow \texttt{buyMaterials} of type \texttt{CIO () Materials}
%% means a task that need no input and produce a \texttt{Materials}. Note that all tasks
%% represented by a \texttt{CIO} arrow will be done concurrently!
\texttt{CIO}是我们使用的arrow类型，用来表示一个可以并行执行的任务。我们使用\texttt{()}
来表示\texttt{NULL}，使用型别为\texttt{CIO () Materials}的arrow \texttt{buyMaterials}
来表示一个不许要任何输入、产生一个型别为\texttt{Materials}的输出的任务。需要注意的是，
所有型别为\texttt{CIO}的arrow表示的任务都是并行执行的。
\begin{figure*}
  \begin{verbatim}
buyMaterials :: CIO () Materials
...     -- some type signature omitted for the sake of space
prepareChrist :: CIO () Party
prepareChrist = 
  buyMaterials >>>
  (id &&& ((trimTree &&& sweepHouse &&& makeDecorators) >>> decorateHouse)) >>>
  holdParty
  \end{verbatim}
  \caption{Code of Christmas Eve problem}
  \label{fig:code-christmas}
%% trimTree :: CIO Materials Tree
%% sweepHouse :: CIO Materials ()
%% makeDecorators :: CIO Materials Decorators
%% decorateHouse :: CIO (Tree, (), Decorators) ()
%% holdParty :: CIO (Dinner, ()) Party
\end{figure*}

%% To be exactly, an arrow \texttt{CIO () Materials} does not produce a value of \texttt{Materials},
%% but a promise of a value of type \texttt{Materials}, that's where the parallelisation of tasks lies.
%% Both the input and output of an arrow of type \texttt{CIO a b} is not an actual value, but a promise,
%% or future instead. You can view a promise as a box to be filled in and it's promised to be
%% filled in some value at some time in the future. So generally, an \texttt{CIO} task arrow
%% take a promise from
%% which it will take its input, and return a promise from which other tasks can take their input.
准确地讲，一个型别为\texttt{CIO () Materials}的arrow不产生一个型别为\texttt{Materials}
的输出，而是产生一个型别为\texttt{Materials}的值的“保证”（promise），这是实现任务并行
执行的关键。所谓“保证”，可以理解为将来会有一个特定类型的值，但这个值现在还不一定处于
可用状态，“保证”就像一个盒子，在将来某一时刻回被填入一个值，这个值可以被用作其他任务的
输入。所以，一般来说，一个型别为\texttt{CIO}的arrow输入一个“保证”，输出一个“保证”，
当输入的“保证”盒子被写入时并行地执行计算，得到结果写入输出的“保证”盒子。

\subsection{Implementation}\label{subsec:implementation}
%% In this subsection, we will show implementation of our concurrent arrow interface. For the sake
%% of space, only the skeleton of implementation should be listed here. Readers who are interested in more
%% details can refer to the project's homepage.\cite{CIOHomepage}
本小节将说明我们的高层抽象接口的具体实现，由于空间原因，只概要说明实现技术，有兴趣
的读者可以参见我们项目的主页。\cite{CIOHomepage}

\subsubsection{The Promise}
%% Indeed, a promise is a synchronous variable between threads. For the simplest case, we can use \texttt{MVar}
%% provided by Concurrent Haskell\cite{Jones1996} to implement the promise.
%% A variable of type \texttt{MVar a} is a box can be
%% taken a value of type \texttt{a} from or put a value into by threads. If a \texttt{MVar} is empty,
%% the threads which want to take a value from it will be put to sleep, and waken up again if some other
%% thread has put a value into it. Similarly, if a \texttt{MVar} contains a value, then threads that want
%% to put a value into it will be suspended and waken up when the \texttt{MVar} is empty again. That's
%% exactly what a promise does!
实际上，“保证”的实现就是一个用于线程间通信的变量。最简单的实现就是使用Concurrent Haskell
\cite{Jones1996}内建的\texttt{MVar}变量。一个型别为\texttt{MVar a}的变量可以看作一个盒子，
线程可以从这个盒子中提取型别为\texttt{a}的值，也可以将一个型别为\texttt{a}的值放入这个盒子。
当盒子中不包含任何可用值时，试图从中提取值的线程将会阻塞直到另外的线程放入一个值，同理，
试图向已经包含可用值的盒子内放入新值的线程也会阻塞，直到有线程将原有的值取出盒子。

\subsubsection{The Concurrent Arrow \texttt{CIO}}
%% Given the promise implementation above, we can now define our concurrent arrow \texttt{CIO}.
假定“保证”就用\texttt{MVar}实现，我们的并行arrow \texttt{CIO}可以按照下述方式实现。

%% First we define a task \texttt{Pool} in which we store all the concurrent tasks. A \texttt{Task} is made up with
%% an input promise, an output promise, and an action to perform. A task pool contains a list of tasks,
%% and a list of \texttt{ThreadId}s, each identify a thread we fork to do a task. The \texttt{ThreadId}s
%% will be used for exception handling, which will be described in section \ref{sec:exception-safety}.
%% After all tasks has been
%% added to the pool using \texttt{pushWork}, we call \texttt{runPool} to create a thread for each task to
%% do the work.
首先我们定义一个任务池（\texttt{Task Pool}），将所有需要执行的任务放入这个\texttt{Pool}。
一个\texttt{Task}由一个输入“保证”，一个输出“保证”与一个操作组成。\texttt{Pool}中的任务
使用一个表来组织，除了\texttt{Task}本身，\texttt{Pool}还维护一个线程号表，线程号的型别
为\texttt{ThreadId}，线程号是线程的唯一标识，而每一个\texttt{Task}最终会由一个线程具体
执行，所有的线程并行工作。\texttt{Pool}中的线程号将用于异常捕获和处理，这一步分将在第
\ref{sec:exception-safety}中予以说明。\texttt{Task}与\texttt{Pool}的定义如下：
\begin{verbatim}
data Task = 
  forall a.
  Action (MVar a) (MVar b) (a -> IO b)
data Pool = Pool {
  pool :: IORef [Task],
  tids :: IORef [ThreadId]
}
pushWork :: Pool -> Task -> IO ()
runPool :: Pool -> IO ()
runPool p = do
  ts <- ...   -- get tasks from p
  forM ts $ \t -> fork t -- fork a thread
\end{verbatim}

%% Then comes the definition of the concurrent arrow. The \texttt{CIO} arrow contains a wrapped function, named as
%% \texttt{runC}. \texttt{runC} takes a task pool and an input promise, add a task waiting for the input promise
%% to the pool, and return the output promise of the new task. The output promise will be used as the input
%% promise for next task.
下面我们定义并行arrow \texttt{CIO}。\texttt{CIO}实质上是一个封装了的函数\texttt{runC}。
\texttt{runC}的输入参数为一个\texttt{Pool}与一个“保证”，\texttt{runC}将向\texttt{Pool}
中添加一个任务，这个任务从”保证“中获取输入，\texttt{runC}给出一个输出”保证“作为结果。
\begin{verbatim}
newtype CIO a b = {
  runC :: Pool -> MVar a -> IO (MVar b)
}
\end{verbatim}

%% Now we have the interface of concurrent arrow, using the arrow combiantors mentioned in section
%% \ref{subsec:haskell-and-arrows}, we can express data-flow problems easily. Here we show two other
%% examples to illustrate how to translate data-flow graphs to code using our arrow interface. The data-flow
%% graphs shown in figure \ref{fig:examples} can be translated as below.
现在我们已经定义好了并行arrow \texttt{CIO}，使用第\ref{subsec:haskell-and-arrows}中列举的
arrow操作接口，我们可以很容易地将数据流图转化为代码实现。这里我们给出另外两个例子，用以
说明将数据流图转化为代码实现的方法。数据流图可以参见图\ref{fig:examples}，转化成
代码表示如下。
\begin{verbatim}
(a) (f &&& g) >>>
    arr (\(a, b) -> ((a, b) b)) >>>
    (h *** j) >>> k
(b) (f &&& g) >>>
    arr (\(a, b) -> (a, ((a, b), b))) >>>
    (h *** (j *** id)) >>> k
\end{verbatim}
\begin{figure}
  \centerline{
    \subfloat[]{
      \includegraphics[scale=0.5]{example1.png}%
      \label{subfig:example1}
    }
    \hfil
    \subfloat[]{
      \includegraphics[scale=0.5]{example2.png}%
      \label{subfig:example2}
    }
  }
  \caption{Data-flow problem examples}
  \label{fig:examples}
\end{figure}

\subsubsection{Create Concurrent Tasks}
%% At last we supply some combinators to create concurrent tasks. Ordinary tasks can be
%% expressed by Haskell functions of type \texttt{a -> IO b}, these functions can be
%% converted to concurrent tasks of type \texttt{CIO a b}. One of there functions is \texttt{conc}:
最后，我们还定义了几个函数用于创建并行任务。在Haskell中任务一般可以用以下
型别为\texttt{a -> IO b}表示，使用我们提供的函数，可以很容易地将这种一般的任务
转换成并行执行的任务\texttt{CIO a b}。一个具有代表性的转换函数型别声明如下：
\begin{verbatim}
    conc :: (a -> IO b) -> CIO a b
\end{verbatim}
%% Using the \texttt{conc} combinator, the data-flow problems would be coded in a programming
%% paradigm which looks like:
使用上面的\texttt{conc}函数，一般的数据流驱动问题可以用下面的编程范式表达。
\begin{verbatim}
task = conc task1 >>>
       (conc task2 &&& conc task3) >>>
       (conc task4 *** conc task5)
\end{verbatim}
%% \begin{figure*}
%%   \begin{verbatim}
%%     conc :: (a -> IO b) -> CIO a b
%%   \end{verbatim}
%%   \caption{Code of Christmas Eve party problem}
%%   \label{fig:code-christmas}
%% \end{figure*}

\section{Exception Safety}\label{sec:exception-safety}
%% In practical programming, catching and handling exceptions is an important issue, especially
%% in a concurrent setting.\cite{Marlow2001} Enhance our design with the ability to handle exceptions is not hard
%% work.
在实际编程解决问题的过程中，捕获与处理异常的发生是一个重要工作，尤其在并行程序设计中
尤其如此。\cite{Marlow2001}为我们的并行arrow增加异常处理能力很重要，但并不难实现。

%% Only the definition of \texttt{runPool} needs to be changed. Compare the code below to previous
%% one defined in section \ref{subsec:implementation}, we can see that we wrap the task with a
%% catch operation. If an exception occurs during running the task, the whole concurrent tasks
%% will be cancelled and all other running threads are killed, thus avoiding any resource leak and
%% no unnecessary work will be done.
我们只需要改动\texttt{runPool}的定义即可，下面的代码给出了\texttt{runPool}的新定义。
与之前第\ref{subsec:implementation}节中的定义相比，我们发现只需在\texttt{task}外围
增加一层\texttt{catch}操作。如果某一个线程执行过程中出现了问题，那么所有正在执行
的其它线程将被取消，这样就避免了资源泄漏。

\begin{verbatim}
runPool p = do
  ts <- ...   -- get tasks from p
  forM ts $ \t -> -- fork a thread
    fork (catch t handler)
\end{verbatim}

\section{Performance}
%% We still use the Christmas Eve problem to measure the performance of our concurrent
%% arrow interface. Suppose Dad will spend 0.5 hour to buy all materials, and it takes
%% 1 hour for Mum to cook the dinner. Three kids can finish there work in 0.6, 0.8 and 0.7 hour
%% respectively and Dad will spend 0.3 hour decorating the house. If all work are done
%% sequentially, it will cost $0.5+1+0.6+0.8+0.7+0.3=3.9$ hours. But all family members should
%% work independently and only 1.6 hours is needed indeed.
本节将继续使用圣诞派对问题来衡量我们的并行arrow接口的性能。假设爸爸购买材料需要
0.5小时，妈妈准备晚餐需要1小时，三个孩子分别需要0.6，0.8，0.7小时完成各自的工作，
孩子们完成工作后爸爸需要0.3小时装饰整个房间。如果所有的工作串行执行，总计需要时间
$0.5+1+0.6+0.8+0.7+0.3=3.9$小时。但实际上，各人的工作可以互不干扰地并行进行，在
进行计算机仿真的时候，所有任务应该是并发而不是串行的。

%% We have three versions of implementation, the first in ordinary sequential style,
%% the second in ordinary concurrent style which explicitly fork threads and synchronize,
%% the third coded with our concurrent arrow interface.
%% The results of all three programs are shown in table \ref{tab:simulating-result}.
%% In the simulation, two OS threads are harnessed in the second and third versions.
%% We use one second to represent an hour. Elapsed time is measured using standard unix
%% \texttt{time} utility. We can see all three programs have the performance as
%% expected, and the version using arrow interface runs as fast as ordinary concurrent
%% version.
为了对比分析，我们给出了圣诞派对问题的三种实现。第一种实现使用串行编程的方法，第二种
使用普通的并行编程技术，即显式地创建线程，同步线程等，第三种实现使用我们的并行
arrow接口。三种实现的结果对比参见表\ref{tab:simulating-result}。在两个并行实现
的版本中，均使用两个操作系统线程。仿真中，使用1秒来代表一个小时，程序的运行时间
使用标准unix工具time测量。从结果我们可以看出，三个版本的实现的运行结果符合我们的
预期，而且使用并行arrow接口的并行版本运行速度与普通并行版本一样快，没有任何性能
损失。
\begin{table}
%% increase table row spacing, adjust to taste
%% \renewcommand{\arraystretch}{1.3}
%% if using array.sty, it might be a good idea to tweak the value of
%% \extrarowheight as needed to properly center the text within the cells
\caption{Simulating result of Christmas Eve properly}
\label{tab:simulating-result}
\centering
\begin{tabular}{|c||c||c||c|}
\hline
Version & Sequential & Explicit Concurrency & Arrow Interface\\
\hline
Time(s) & 3.909 & 1.606 & 1.606\\
\hline
\end{tabular}
\end{table}
%% The terminal output is modified to save space. The result show that our arrow
%% interface works well and can reach almost the ideal performance.
%% \begin{verbatim}
%% $> time christmas_cio
%% "Dad: All materials are here!"
%% "Tommy: A beauful Christmas Tree!"
%% "Lucy: How beautiful the decorators are!"
%% "David: Sweeping the house is tiresome!"
%% "Mum: Dinner is ready!"
%% "Dad: The house is decorated!"
%% "All work is done! The party begins!"

%% real	0m1.606s
%% $> time christmas
%% "Dad: All materials are here!"
%% ... # same as above with order changed
%% real	0m3.909s
%% \end{verbatim}

%% In the Christmas Eve testcase, we put threads to sleep to simulate time elapsing and the
%% processors actually do no meaningful work. We will use another testcase to show how are the concurrent
%% tasks are scheduled on multiple OS threads. In this testcase we want to find all prime numbers in a range 
%% $[0, n]$. Because the primeness judgements of integral numbers are indepedent of each other, so we can
%% adopt a divide-and-conquer algorithm. The big range is splited to some smaller ones and computed
%% indepedently, and the results are collected as a whole at last. We show the data-flow graph in figure
%% \ref{fig:divide-and-conquer}. We use the ThreadScope utility to show the runtime statistics of our program, as
%% shown in figure \ref{fig:runtime-statistics}. Two OS threads are harnessed, named as HEC0 and HEC1,
%% the green bar means the OS thread is working, and yellow bar stands for garbage collecting operations done
%% by the Haskell Runtime System. From figure \ref{fig:runtime-statistics} we see that all workload are banlanced
%% well on multiple OS threads.
在圣诞派对问题的测试中，我们只是简单地另线程休眠（\texttt{sleep}）来仿真
完成任务耗费的时间，这期间处理器没有做任何工作。下面我们使用另一个测试实例
来说明并行任务是如何在多个线程中被调度。在这个测试中，我们的任务是找出某个
自然数序列$[0, n]$中的所有素数。因为对不同的数进行素数判定是独立的，所以可以
并行进行。这里我们使用分治的策略，将整个序列分成多个子序列，分别进行处理，最后
合并结果。分治法解决序列素数判定问题可以用图\ref{fig:divide-and-conquer}中
的数据流图表示。我们使用ThreadScope工具获得程序的运行状况，参见
图\ref{fig:runtime-statistics}。这里使用了两个操作系统线程，分别为HEC0与HEC1,
图中绿色的条块表示响应的操作系统线程正处于工作状态，黄色条块代表Haskell的
运行时系统正在执行垃圾回收操作。从图\ref{fig:runtime-statistics}中可以看出，
所有的工作负载可以被平衡地分布到不同的操作系统线程中，而且这部分工作是由
Hasekll的运行时系统自动完成，无须编程者控制。
\begin{figure}
  \centering
  \includegraphics[scale=0.38]{example3.png}
  \caption{Data-flow graph of divide-and-conquer}
  \label{fig:divide-and-conquer}
\end{figure}
\begin{figure*}[!t]
  \centerline{
    \subfloat[Workload on multiple OS threads]{
      \includegraphics[scale=0.3]{divide-and-conquer.png}%
      \label{subfig:runtime-statistics}
    }
    \hfil
    \subfloat[Time line zoomed in for details]{
      \includegraphics[scale=0.3]{divide-and-conquer-details.png}%
      \label{subfig:runtime-statistics-details}
    }
  }
  \caption{Runtime statistics of divide-and-conquer}
  \label{fig:runtime-statistics}
\end{figure*}

%% \begin{figure*}
%%   \centering
%%   \includegraphics[scale=0.35]{divide-and-conquer.png}
%%   \caption{Runtime statistics of divide-and-conquer}
%%   \label{fig:runtime-statistics}
%% \end{figure*}

\section{Conclusion}
%% In this paper we show our design of a high-level abstraction of data-flow drived concurrent
%% programming, which enable the programmers to directly translate a data-flow problem into proper
%% code. The code looks like a sequential one, but work concurrently indeed. All labour required is
%% the use of our \texttt{conc} combinator to convert ordinary tasks to a concurrent ones, which means
%% the programmers are freed from taking care of all the subtle details of concurrent programming.
本文提出了一种高层的、抽线的接口设计，可以用来表达数据流驱动问题，并自动
并行执行。这种接口使编程者无须考虑并行编程的诸多细节，只需要将数据流图翻译成
合适的代码实现，并行化就会自动完成，编程者唯一需要做的就是使用我们
的\texttt{conc}函数，将普通任务转化为并行任务，这就大大简化了编程工作。

%% The main contributions are:
%% \begin{itemize}
%%   \item An elegant arrow interface for expressing data-flow problems.
%%   \item The concurrent tasks is automatically scheduled, without disturbing the programmers.
%%   \item Good performance with exception safety.
%% \end{itemize}
本文的主要贡献如下：
\begin{itemize}
  \item 一个优雅的arrow接口，可以方便地表达数据流驱动问题；
  \item 并行化任务自动完成，调度工作无须由编程者完成；
  \item 良好的性能与异常处理的能力。
\end{itemize}

%% The idea of maintaining a task pool is inspired by Marlow's Par monad.\cite{Marlow2011a}
%% The Par monad works for
%% determinated computation, our design works with non-determinated computation.
%% Our work is based on Peyton Jones's Concurrent Haskell\cite{Jones1996} 
%% is more general than our arrow interface while our design are best fit for data-flow problems.
使用一个Task Pool维护并行任务的想法得益于Marlow的Par Monad。\cite{Marlow2011a}
Par Monad的特点是，计算是确定性的（determinated），我们的并行接口是非确定性的。
我们的工作建立在Peyton Jones的Concurrent Haskell之上\cite{Jones1996},
Concurrent Haskell为并行编程提供了较为底层的支持，我们的设计抽线层次高，
主要面向数据流驱动问题。

%% The disadvantage of our work is that it can only handle tasks with one parameter, say functions of
%% type \texttt{a -> IO b}. For multi-parameter tasks of type \texttt{a -> b -> IO c} you must uncurry
%% it to a task of type \texttt{(a, b) -> IO c} before calling \texttt{conc}. This is a future work
%% we shall consider about, And we think the using HList\cite{Kiselyov2004} and other
%% type-level programming techniques seems to be a promising method.
本文工作的不足之处在于，并行arrow接口只能处理只有一个输入的任务，即
具有型别\texttt{a -> IO b}的函数，对于多参数的情况，如型别为\texttt{a -> b -> IO c}
的情况，编程者必须手动进行反柯里化将多参数函数转换为单参数函数之后，
才能使用\texttt{conc}函数。这是下一步要进行的工作之一，而且HList\cite{Kiselyov2004}
为这个工作提供了有益的参考。

% conference papers do not normally have an appendix


% use section* for acknowledgement
\section*{Acknowledgment}
This research is supported by National Natural Science Foundation of China
(Grant No. 61103010, 61103190, 60803100), National Basic Research Program
of China (Grant No. 2012CB933500) and High Technology Research and Development
Program of China (Grant No. 2012AA012201,2012AA011902).

% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
%% \begin{thebibliography}{1}

%% \bibitem{IEEEhowto:kopka}
%% H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
%%   0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

%% \end{thebibliography}

\bibliography{refs.bib}


% that's all folks
\end{document}


